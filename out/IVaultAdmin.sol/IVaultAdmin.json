{"abi":[{"type":"function","name":"addLiquidityToBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"maxAmountUnderlyingInRaw","type":"uint256","internalType":"uint256"},{"name":"maxAmountWrappedInRaw","type":"uint256","internalType":"uint256"},{"name":"exactSharesToIssue","type":"uint256","internalType":"uint256"},{"name":"sharesOwner","type":"address","internalType":"address"}],"outputs":[{"name":"amountUnderlyingRaw","type":"uint256","internalType":"uint256"},{"name":"amountWrappedRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"areBuffersPaused","inputs":[],"outputs":[{"name":"buffersPaused","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"collectAggregateFees","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[{"name":"swapFeeAmounts","type":"uint256[]","internalType":"uint256[]"},{"name":"yieldFeeAmounts","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"nonpayable"},{"type":"function","name":"disableQuery","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"disableQueryPermanently","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"disableRecoveryMode","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"enableQuery","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"enableRecoveryMode","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBufferAsset","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"underlyingToken","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"getBufferBalance","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"underlyingBalanceRaw","type":"uint256","internalType":"uint256"},{"name":"wrappedBalanceRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getBufferMinimumTotalSupply","inputs":[],"outputs":[{"name":"bufferMinimumTotalSupply","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getBufferOwnerShares","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"liquidityOwner","type":"address","internalType":"address"}],"outputs":[{"name":"ownerShares","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getBufferPeriodDuration","inputs":[],"outputs":[{"name":"bufferPeriodDuration","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getBufferPeriodEndTime","inputs":[],"outputs":[{"name":"bufferPeriodEndTime","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getBufferTotalShares","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"bufferShares","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMaximumPoolTokens","inputs":[],"outputs":[{"name":"maxTokens","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getMinimumPoolTokens","inputs":[],"outputs":[{"name":"minTokens","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getMinimumTradeAmount","inputs":[],"outputs":[{"name":"minimumTradeAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMinimumWrapAmount","inputs":[],"outputs":[{"name":"minimumWrapAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getPauseWindowEndTime","inputs":[],"outputs":[{"name":"pauseWindowEndTime","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getPoolMinimumTotalSupply","inputs":[],"outputs":[{"name":"poolMinimumTotalSupply","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getVaultPausedState","inputs":[],"outputs":[{"name":"vaultPaused","type":"bool","internalType":"bool"},{"name":"vaultPauseWindowEndTime","type":"uint32","internalType":"uint32"},{"name":"vaultBufferPeriodEndTime","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"initializeBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"amountUnderlyingRaw","type":"uint256","internalType":"uint256"},{"name":"amountWrappedRaw","type":"uint256","internalType":"uint256"},{"name":"minIssuedShares","type":"uint256","internalType":"uint256"},{"name":"sharesOwner","type":"address","internalType":"address"}],"outputs":[{"name":"issuedShares","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"isVaultPaused","inputs":[],"outputs":[{"name":"vaultPaused","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"pausePool","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"pauseVault","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"pauseVaultBuffers","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"removeLiquidityFromBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"sharesToRemove","type":"uint256","internalType":"uint256"},{"name":"minAmountUnderlyingOutRaw","type":"uint256","internalType":"uint256"},{"name":"minAmountWrappedOutRaw","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"removedUnderlyingBalanceRaw","type":"uint256","internalType":"uint256"},{"name":"removedWrappedBalanceRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"setAuthorizer","inputs":[{"name":"newAuthorizer","type":"address","internalType":"contract IAuthorizer"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setProtocolFeeController","inputs":[{"name":"newProtocolFeeController","type":"address","internalType":"contract IProtocolFeeController"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setStaticSwapFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"swapFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpausePool","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpauseVault","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpauseVaultBuffers","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateAggregateSwapFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"newAggregateSwapFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateAggregateYieldFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"newAggregateYieldFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"vault","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IVault"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"addLiquidityToBuffer(address,uint256,uint256,uint256,address)":"e2a92b1a","areBuffersPaused()":"55cba7fe","collectAggregateFees(address)":"8f4ab9ca","disableQuery()":"de1a36a6","disableQueryPermanently()":"821440f2","disableRecoveryMode(address)":"bffb78b2","enableQuery()":"e0d55605","enableRecoveryMode(address)":"dc3f574e","getBufferAsset(address)":"0387587d","getBufferBalance(address)":"4021fe0f","getBufferMinimumTotalSupply()":"26a8a991","getBufferOwnerShares(address,address)":"9385e39a","getBufferPeriodDuration()":"20c1fb7a","getBufferPeriodEndTime()":"cd51c12f","getBufferTotalShares(address)":"f2784e07","getMaximumPoolTokens()":"2e42f4d5","getMinimumPoolTokens()":"a8175b27","getMinimumTradeAmount()":"e2cb0ba0","getMinimumWrapAmount()":"53956aa2","getPauseWindowEndTime()":"8a8d123a","getPoolMinimumTotalSupply()":"d0965a6b","getVaultPausedState()":"85c8c015","initializeBuffer(address,uint256,uint256,uint256,address)":"653eb3b0","isVaultPaused()":"098401f5","pausePool(address)":"55aca1ec","pauseVault()":"9e0879c2","pauseVaultBuffers()":"e085c5a8","removeLiquidityFromBuffer(address,uint256,uint256,uint256)":"ebc7955c","setAuthorizer(address)":"058a628f","setProtocolFeeController(address)":"2d771389","setStaticSwapFeePercentage(address,uint256)":"d15126ba","unpausePool(address)":"f21c38cd","unpauseVault()":"0b7562be","unpauseVaultBuffers()":"b9212b49","updateAggregateSwapFeePercentage(address,uint256)":"5e0b06f4","updateAggregateYieldFeePercentage(address,uint256)":"e253670a","vault()":"fbfa77cf"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountUnderlyingInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountWrappedInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exactSharesToIssue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sharesOwner\",\"type\":\"address\"}],\"name\":\"addLiquidityToBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlyingRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWrappedRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"areBuffersPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"buffersPaused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"collectAggregateFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swapFeeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldFeeAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableQuery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableQueryPermanently\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"disableRecoveryMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableQuery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"enableRecoveryMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingBalanceRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wrappedBalanceRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferMinimumTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bufferMinimumTotalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityOwner\",\"type\":\"address\"}],\"name\":\"getBufferOwnerShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferPeriodDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferPeriodEndTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"bufferPeriodEndTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bufferShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTradeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumTradeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumWrapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumWrapAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseWindowEndTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"pauseWindowEndTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolMinimumTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolMinimumTotalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultPausedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"vaultPaused\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"vaultPauseWindowEndTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"vaultBufferPeriodEndTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountUnderlyingRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWrappedRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minIssuedShares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sharesOwner\",\"type\":\"address\"}],\"name\":\"initializeBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"issuedShares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVaultPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"vaultPaused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"pausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseVaultBuffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesToRemove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountUnderlyingOutRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountWrappedOutRaw\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityFromBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"removedUnderlyingBalanceRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"removedWrappedBalanceRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"name\":\"setAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolFeeController\",\"name\":\"newProtocolFeeController\",\"type\":\"address\"}],\"name\":\"setProtocolFeeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setStaticSwapFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"unpausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseVaultBuffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAggregateSwapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updateAggregateSwapFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAggregateYieldFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updateAggregateYieldFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"`VaultAdmin` is the Proxy extension of `VaultExtension`, and handles the least critical operations, as two delegate calls add gas to each call. Most of the permissioned calls are here.\",\"kind\":\"dev\",\"methods\":{\"addLiquidityToBuffer(address,uint256,uint256,uint256,address)\":{\"details\":\"The buffer needs to be initialized beforehand.\",\"params\":{\"exactSharesToIssue\":\"The value in underlying tokens that `sharesOwner` wants to add to the buffer, in underlying token decimals\",\"maxAmountUnderlyingInRaw\":\"Maximum amount of underlying tokens to add to the buffer. It is expressed in underlying token native decimals\",\"maxAmountWrappedInRaw\":\"Maximum amount of wrapped tokens to add to the buffer. It is expressed in wrapped token native decimals\",\"sharesOwner\":\"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"amountUnderlyingRaw\":\"Amount of underlying tokens deposited into the buffer\",\"amountWrappedRaw\":\"Amount of wrapped tokens deposited into the buffer\"}},\"areBuffersPaused()\":{\"details\":\"When buffers are paused, all buffer operations (i.e., calls on the Router with `isBuffer` true) will revert. Pausing buffers is reversible. Note that ERC4626 buffers and the Vault have separate and independent pausing mechanisms. Pausing the Vault does not also pause buffers (though we anticipate they would likely be paused and unpaused together). Call `isVaultPaused` to check the pause state of the Vault.\",\"returns\":{\"buffersPaused\":\"True if the Vault buffers are paused\"}},\"collectAggregateFees(address)\":{\"details\":\"Fees are sent to the ProtocolFeeController address.\",\"params\":{\"pool\":\"The pool on which all aggregate fees should be collected\"},\"returns\":{\"swapFeeAmounts\":\"An array with the total swap fees collected, sorted in token registration order\",\"yieldFeeAmounts\":\"An array with the total yield fees collected, sorted in token registration order\"}},\"disableQuery()\":{\"details\":\"The query functions rely on a specific EVM feature to detect static calls. Query operations are exempt from settlement constraints, so it's critical that no state changes can occur. We retain the ability to disable queries in the unlikely event that EVM changes violate its assumptions (perhaps on an L2). This function can be acted upon as an emergency measure in ambiguous contexts where it's not 100% clear whether disabling queries is completely necessary; queries can still be re-enabled after this call.\"},\"disableQueryPermanently()\":{\"details\":\"Shall only be used when there is no doubt that queries pose a fundamental threat to the system.\"},\"disableRecoveryMode(address)\":{\"details\":\"This is a permissioned function. It re-syncs live balances (which could not be updated during Recovery Mode), forfeiting any yield fees that accrued while enabled. It makes external calls, and could potentially fail if there is an issue with any associated Rate Providers.\",\"params\":{\"pool\":\"The address of the pool\"}},\"enableQuery()\":{\"details\":\"Only works if queries are not permanently disabled.\"},\"enableRecoveryMode(address)\":{\"details\":\"This is a permissioned function. It enables a safe proportional withdrawal, with no external calls. Since there are no external calls, ensuring that entering Recovery Mode cannot fail, we cannot compute and so must forfeit any yield fees between the last operation and enabling Recovery Mode. For the same reason, live balances cannot be updated while in Recovery Mode, as doing so might cause withdrawals to fail.\",\"params\":{\"pool\":\"The address of the pool\"}},\"getBufferAsset(address)\":{\"details\":\"The asset can never change after buffer initialization.\",\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"underlyingToken\":\"Address of the underlying token registered for the wrapper; `address(0)` if the buffer has not been initialized.\"}},\"getBufferBalance(address)\":{\"details\":\"All values are in native token decimals of the wrapped or underlying tokens.\",\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"underlyingBalanceRaw\":\"Amount of underlying tokens deposited into the buffer, in native token decimals\",\"wrappedBalanceRaw\":\"Amount of wrapped tokens deposited into the buffer, in native token decimals\"}},\"getBufferMinimumTotalSupply()\":{\"details\":\"This prevents buffers from being completely drained. When the buffer is initialized, this minimum number of shares is added to the shares resulting from the initial deposit. Buffer total supply accounting is internal to the Vault, as buffers are not tokenized.\",\"returns\":{\"bufferMinimumTotalSupply\":\"The minimum total supply a buffer can have after initialization\"}},\"getBufferOwnerShares(address,address)\":{\"params\":{\"liquidityOwner\":\"Address of the user that owns liquidity in the wrapped token's buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"ownerShares\":\"Amount of shares allocated to the liquidity owner, in native underlying token decimals\"}},\"getBufferPeriodDuration()\":{\"details\":\"This value is immutable. It represents the period during which, if paused, the Vault will remain paused. This ensures there is time available to address whatever issue caused the Vault to be paused. Balancer timestamps are 32 bits.\",\"returns\":{\"bufferPeriodDuration\":\"The length of the buffer period in seconds\"}},\"getBufferPeriodEndTime()\":{\"details\":\"This value is immutable. If already paused, the Vault can be unpaused until this timestamp. Balancer timestamps are 32 bits.\",\"returns\":{\"bufferPeriodEndTime\":\"The timestamp after which the Vault remains permanently unpaused\"}},\"getBufferTotalShares(address)\":{\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"bufferShares\":\"Amount of supply shares of the buffer, in native underlying token decimals\"}},\"getMaximumPoolTokens()\":{\"returns\":{\"maxTokens\":\"The maximum token count of a pool\"}},\"getMinimumPoolTokens()\":{\"details\":\"We expect the vast majority of pools to be 2-token.\",\"returns\":{\"minTokens\":\"The minimum token count of a pool\"}},\"getMinimumTradeAmount()\":{\"details\":\"This limit is applied to the 18-decimal \\\"upscaled\\\" amount in any operation (swap, add/remove liquidity).\",\"returns\":{\"minimumTradeAmount\":\"The minimum trade amount as an 18-decimal floating point number\"}},\"getMinimumWrapAmount()\":{\"details\":\"This limit is applied to the wrap operation amount, in native underlying token decimals.\",\"returns\":{\"minimumWrapAmount\":\"The minimum wrap amount in native underlying token decimals\"}},\"getPauseWindowEndTime()\":{\"details\":\"This value is immutable, and represents the timestamp after which the Vault can no longer be paused by governance. Balancer timestamps are 32 bits.\",\"returns\":{\"pauseWindowEndTime\":\"The timestamp when the Vault's pause window ends\"}},\"getPoolMinimumTotalSupply()\":{\"details\":\"This prevents pools from being completely drained. When the pool is initialized, this minimum amount of BPT is minted to the zero address. This is an 18-decimal floating point number; BPT are always 18 decimals.\",\"returns\":{\"poolMinimumTotalSupply\":\"The minimum total supply a pool can have after initialization\"}},\"getVaultPausedState()\":{\"details\":\"Balancer timestamps are 32 bits.\",\"returns\":{\"vaultBufferPeriodEndTime\":\"The timestamp of the end of the Vault's buffer period\",\"vaultPauseWindowEndTime\":\"The timestamp of the end of the Vault's pause window\",\"vaultPaused\":\"True if the Vault is paused\"}},\"initializeBuffer(address,uint256,uint256,uint256,address)\":{\"params\":{\"amountUnderlyingRaw\":\"Amount of underlying tokens that will be deposited into the buffer\",\"amountWrappedRaw\":\"Amount of wrapped tokens that will be deposited into the buffer\",\"minIssuedShares\":\"Minimum amount of shares to receive from the buffer, expressed in underlying token native decimals\",\"sharesOwner\":\"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"issuedShares\":\"the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts. (it is the BPT of an internal ERC4626 buffer). It is expressed in underlying token native decimals.\"}},\"isVaultPaused()\":{\"details\":\"If the Vault is paused, all non-Recovery Mode state-changing operations on pools will revert. Note that ERC4626 buffers and the Vault have separate and independent pausing mechanisms. Pausing the Vault does not also pause buffers (though we anticipate they would likely be paused and unpaused together). Call `areBuffersPaused` to check the pause state of the buffers.\",\"returns\":{\"vaultPaused\":\"True if the Vault is paused\"}},\"pausePool(address)\":{\"details\":\"This is a permissioned function that will only work during the Pause Window set during pool factory deployment.\",\"params\":{\"pool\":\"The pool being paused\"}},\"pauseVault()\":{\"details\":\"This is a permissioned function that will only work during the Pause Window set during deployment. Note that ERC4626 buffer operations have an independent pause mechanism, which is not affected by pausing the Vault. Custom routers could still wrap/unwrap using buffers while the Vault is paused, unless buffers are also paused (with `pauseVaultBuffers`).\"},\"pauseVaultBuffers()\":{\"details\":\"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. Currently it's not possible to pause vault buffers individually. This is a permissioned call, and is reversible (see `unpauseVaultBuffers`). Note that the Vault has a separate and independent pausing mechanism. It is possible to pause the Vault (i.e. pool operations), without affecting buffers, and vice versa.\"},\"removeLiquidityFromBuffer(address,uint256,uint256,uint256)\":{\"details\":\"Only proportional exits are supported, and the sender has to be the owner of the shares. This function unlocks the Vault just for this operation; it does not work with a Router as an entrypoint. Pre-conditions: - The buffer needs to be initialized. - sharesOwner is the original msg.sender, it needs to be checked in the Router. That's why   this call is authenticated; only routers approved by the DAO can remove the liquidity of a buffer. - The buffer needs to have some liquidity and have its asset registered in `_bufferAssets` storage.\",\"params\":{\"minAmountUnderlyingOutRaw\":\"Minimum amount of underlying tokens to receive from the buffer. It is expressed in underlying token native decimals\",\"minAmountWrappedOutRaw\":\"Minimum amount of wrapped tokens to receive from the buffer. It is expressed in wrapped token native decimals\",\"sharesToRemove\":\"Amount of shares to remove from the buffer. Cannot be greater than sharesOwner's total shares. It is expressed in underlying token native decimals\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"removedUnderlyingBalanceRaw\":\"Amount of underlying tokens returned to the user\",\"removedWrappedBalanceRaw\":\"Amount of wrapped tokens returned to the user\"}},\"setAuthorizer(address)\":{\"details\":\"This is a permissioned call. Emits an `AuthorizerChanged` event.\",\"params\":{\"newAuthorizer\":\"The address of the new authorizer\"}},\"setProtocolFeeController(address)\":{\"details\":\"This is a permissioned call. Emits a `ProtocolFeeControllerChanged` event.\",\"params\":{\"newProtocolFeeController\":\"The address of the new Protocol Fee Controller\"}},\"setStaticSwapFeePercentage(address,uint256)\":{\"details\":\"This is a permissioned function, disabled if the pool is paused. The swap fee percentage must be within the bounds specified by the pool's implementation of `ISwapFeePercentageBounds`. Emits the SwapFeePercentageChanged event.\",\"params\":{\"pool\":\"The address of the pool for which the static swap fee will be changed\",\"swapFeePercentage\":\"The new swap fee percentage to apply to the pool\"}},\"unpausePool(address)\":{\"details\":\"This is a permissioned function that will only work on a paused Pool within the Buffer Period set during deployment. Note that the Pool will automatically unpause after the Buffer Period expires.\",\"params\":{\"pool\":\"The pool being unpaused\"}},\"unpauseVault()\":{\"details\":\"This is a permissioned function that will only work on a paused Vault within the Buffer Period set during deployment. Note that the Vault will automatically unpause after the Buffer Period expires. As noted above, ERC4626 buffers and Vault operations on pools are independent. Unpausing the Vault does not reverse `pauseVaultBuffers`. If buffers were also paused, they will remain in that state until explicitly unpaused.\"},\"unpauseVaultBuffers()\":{\"details\":\"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. As noted above, ERC4626 buffers and Vault operations on pools are independent. Unpausing buffers does not reverse `pauseVault`. If the Vault was also paused, it will remain in that state until explicitly unpaused. This is a permissioned call.\"},\"updateAggregateSwapFeePercentage(address,uint256)\":{\"details\":\"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateSwapFeePercentageChanged` event.\",\"params\":{\"newAggregateSwapFeePercentage\":\"The new aggregate swap fee percentage\",\"pool\":\"The pool whose swap fee percentage will be updated\"}},\"updateAggregateYieldFeePercentage(address,uint256)\":{\"details\":\"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateYieldFeePercentageChanged` event.\",\"params\":{\"newAggregateYieldFeePercentage\":\"The new aggregate yield fee percentage\",\"pool\":\"The pool whose yield fee percentage will be updated\"}},\"vault()\":{\"details\":\"The main Vault contains the entrypoint and main liquidity operation implementations.\",\"returns\":{\"_0\":\"vault The address of the main Vault\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addLiquidityToBuffer(address,uint256,uint256,uint256,address)\":{\"notice\":\"Adds liquidity to an internal ERC4626 buffer in the Vault, proportionally.\"},\"areBuffersPaused()\":{\"notice\":\"Indicates whether the Vault buffers are paused.\"},\"collectAggregateFees(address)\":{\"notice\":\"Collects accumulated aggregate swap and yield fees for the specified pool.\"},\"disableQuery()\":{\"notice\":\"Disables query functionality on the Vault. Can only be called by governance.\"},\"disableQueryPermanently()\":{\"notice\":\"Disables query functionality permanently on the Vault. Can only be called by governance.\"},\"disableRecoveryMode(address)\":{\"notice\":\"Disable recovery mode for a pool.\"},\"enableQuery()\":{\"notice\":\"Enables query functionality on the Vault. Can only be called by governance.\"},\"enableRecoveryMode(address)\":{\"notice\":\"Enable recovery mode for a pool.\"},\"getBufferAsset(address)\":{\"notice\":\"Returns the asset registered for a given wrapped token.\"},\"getBufferBalance(address)\":{\"notice\":\"Returns the amount of underlying and wrapped tokens deposited in the internal buffer of the Vault.\"},\"getBufferMinimumTotalSupply()\":{\"notice\":\"Get the minimum total supply of an ERC4626 wrapped token buffer in the Vault.\"},\"getBufferOwnerShares(address,address)\":{\"notice\":\"Returns the shares (internal buffer BPT) of a liquidity owner: a user that deposited assets in the buffer.\"},\"getBufferPeriodDuration()\":{\"notice\":\"Returns the Vault's buffer period duration.\"},\"getBufferPeriodEndTime()\":{\"notice\":\"Returns the Vault's buffer period end time.\"},\"getBufferTotalShares(address)\":{\"notice\":\"Returns the supply shares (internal buffer BPT) of the ERC4626 buffer.\"},\"getMaximumPoolTokens()\":{\"notice\":\"Get the maximum number of tokens in a pool.\"},\"getMinimumPoolTokens()\":{\"notice\":\"Get the minimum number of tokens in a pool.\"},\"getMinimumTradeAmount()\":{\"notice\":\"Get the minimum trade amount in a pool operation.\"},\"getMinimumWrapAmount()\":{\"notice\":\"Get the minimum wrap amount in a buffer operation.\"},\"getPauseWindowEndTime()\":{\"notice\":\"Returns the Vault's pause window end time.\"},\"getPoolMinimumTotalSupply()\":{\"notice\":\"Get the minimum total supply of pool tokens (BPT) for an initialized pool.\"},\"getVaultPausedState()\":{\"notice\":\"Returns the paused status, and end times of the Vault's pause window and buffer period.\"},\"initializeBuffer(address,uint256,uint256,uint256,address)\":{\"notice\":\"Initializes buffer for the given wrapped token.\"},\"isVaultPaused()\":{\"notice\":\"Indicates whether the Vault is paused.\"},\"pausePool(address)\":{\"notice\":\"Pause the Pool: an emergency action which disables all pool functions.\"},\"pauseVault()\":{\"notice\":\"Pause the Vault: an emergency action which disables all operational state-changing functions on pools.\"},\"pauseVaultBuffers()\":{\"notice\":\"Pauses native vault buffers globally.\"},\"removeLiquidityFromBuffer(address,uint256,uint256,uint256)\":{\"notice\":\"Removes liquidity from an internal ERC4626 buffer in the Vault.\"},\"setAuthorizer(address)\":{\"notice\":\"Sets a new Authorizer for the Vault.\"},\"setProtocolFeeController(address)\":{\"notice\":\"Sets a new Protocol Fee Controller for the Vault.\"},\"setStaticSwapFeePercentage(address,uint256)\":{\"notice\":\"Assigns a new static swap fee percentage to the specified pool.\"},\"unpausePool(address)\":{\"notice\":\"Reverse a `pause` operation, and restore the Pool to normal functionality.\"},\"unpauseVault()\":{\"notice\":\"Reverse a `pause` operation, and restore Vault pool operations to normal functionality.\"},\"unpauseVaultBuffers()\":{\"notice\":\"Unpauses native vault buffers globally.\"},\"updateAggregateSwapFeePercentage(address,uint256)\":{\"notice\":\"Update an aggregate swap fee percentage.\"},\"updateAggregateYieldFeePercentage(address,uint256)\":{\"notice\":\"Update an aggregate yield fee percentage.\"},\"vault()\":{\"notice\":\"Returns the main Vault address.\"}},\"notice\":\"Interface for functions defined on the `VaultAdmin` contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol\":\"IVaultAdmin\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[\":@openzeppelin-4/contracts/=../../node_modules/@openzeppelin/contracts/\",\":@openzeppelin/contracts-upgradeable/=../../node_modules/@openzeppelin/contracts-upgradeable/\",\":@openzeppelin/contracts/=../../node_modules/@openzeppelin/contracts/\",\":balancer-v3-monorepo/=lib/balancer-v3-monorepo/\",\":beefy-zk/=node_modules/beefy-zk/contracts/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=../../node_modules/@openzeppelin/contracts-upgradeable/\",\":solidity-bytes-utils/=node_modules/solidity-bytes-utils/\"],\"viaIR\":true},\"sources\":{\"../../node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x5a173dcd1c1f0074e4df6a9cdab3257e17f2e64f7b8f30ca9e17a8c5ea250e1c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7883819ce2b72264a756063ae578661f62b23f4104b08e9565ac075e619f6ce3\",\"dweb:/ipfs/QmcSZdFiEQkWRmZQhnCdfH9ychooV81pBjr7hfaiYiNZT2\"]},\"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5\",\"dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53\"]},\"../../node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5a376d3dda2cb70536c0a45c208b29b34ac560c4cb4f513a42079f96ba47d2dd\",\"dweb:/ipfs/QmZQg6gn1sUpM8wHzwNvSnihumUCAhxD119MpXeKp8B9s8\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IAuthentication.sol\":{\"keccak256\":\"0xa383f78ec04a4ebadbf64ce0fcef8c14f2487f02330acf2fbab80055c54a5d74\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://077fdb9728fd22008ca58ca9f63cc7ea1b86f9cec778c5ff8943d9322b812f06\",\"dweb:/ipfs/QmVCYYCeuUZK1GqAHzTZBo59cjjh9iQhNYWQvAy2AYAVoN\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x3a9a626d90cdf64042441895ce981bf570d9aa56e7c188b34f8603b1d629aae3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://0ac7096c0d5cd5e0c20dcc6681d24eb04ad7e14cbb61d0ebf136f96a2b9752c4\",\"dweb:/ipfs/QmWryZQqLxpxaCBwK6uEfSLKWKsGBsDL7xbdGqFMkW4Uxp\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol\":{\"keccak256\":\"0x288b9590b9fb743964d46f610c2b0d4eee8457bfe52b890e31be5e11661759e3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://11373e74f2bb6112ae47b709e0161c09b3a2e1a7659bd15fa4ab4bcf8eadcab0\",\"dweb:/ipfs/QmfELyCgCckJz6hPwCw9thNA5kvaoUcCw7gcoxRgWrjMg1\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol\":{\"keccak256\":\"0x51fabcdeaefc15a895a04c457968a7fc0ce4f4647d42a91d07a863170d812c28\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://85822ed25a050521ec4b1af2e21d48e2b85cf48828cb9be5d7e5eb104d4ade6a\",\"dweb:/ipfs/QmU4QSNMfQCEacdgQizCxgNUzfnKxdmyqAndNJgLsCQ32t\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IProtocolFeeController.sol\":{\"keccak256\":\"0xa549105cdf64e06ab49473ab810b4ec2342e7e1593707a297f7965044d75fdb1\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://f641d0f440b2085580aa8b79cb3241bc0c3ea0af275fad953d727ec8f7482795\",\"dweb:/ipfs/QmPULYHXMhCGCztE5ccKzRhb99K3LJSAicbxpWm36gcFVg\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVault.sol\":{\"keccak256\":\"0xf02dcb0b4fe9b71eb46fc66e327e166091d4e479fc3987c766859c94d505fe03\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://de42ab0fa6f22010ac305d785e787a60fbb94c2d0ba17042a6e60bce33c5ed9f\",\"dweb:/ipfs/QmVonnCCZVGzA3EERuQ4PbtpTTKrtgoXxYmtJ4CqaSmc4e\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol\":{\"keccak256\":\"0x9a651c10b5b352386341d65a37b63c95fbd0c4d401d4539730f3dfb4825acc18\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://26e398b4fc37c80a86327b9cbe14335e5378fa69b3fb222c2dc8cf33707c30fd\",\"dweb:/ipfs/QmY2E1b8DADLp3MStbVK93GACRJgJZxHYJpDrow1xzVhWB\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultErrors.sol\":{\"keccak256\":\"0xb2c6deaa8701201af5d31ac270fbc30ebe6b66a1f9b6b12d1d17d807f7decb66\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://28d6751bc7e7c7221745742cfe906387e0d806ea0a0041b9377fb5a537146063\",\"dweb:/ipfs/QmcphjQ6ramZM6Qxv84jaJbtZ7d5FNFJ8xHWCHZwk7CdZ3\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultEvents.sol\":{\"keccak256\":\"0x0ff416b358949bb5d9553118f7cbfd42aa9aa33fa6bbe4bf470159df07cf6989\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://f033bb516eb8d85554aea408a0a750bf6ccd5655035abd307cc8388a533f1c40\",\"dweb:/ipfs/QmPCjG5jrXU4FrJWsputirF7JXZsNxhopetnHZTfRAFvMn\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultExtension.sol\":{\"keccak256\":\"0xa547348926764942de6030bf7d303684ff675a4a08fab3320f98154450ca5bb8\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://6c440d5d23034e35803f135d9336f256ece717370adb93d1f2fb992fa5ffd869\",\"dweb:/ipfs/QmbCaxRG3X9kUEbdrhRbm7JZZoK2nYp8FUXqh7Bn4wnFra\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":{\"keccak256\":\"0x7df60e55516bf9cfa5156a03afc22e222fb87edf1bb9af48586ff0ff1be71e92\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://baf5a2e16cdb139182df24e2d103f80c72b730be20a04b2486e751af16652ac9\",\"dweb:/ipfs/Qmd6kdQmUFxPRJT1YrRJVVsUYAmpohBRvCM2qdXzVGcv5d\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0x670a4c7cdc970ed8cc82432894318558d67a530591617177603e0fea631addbc\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://b240af11378ac8ce54000b7defbd63c3a78d34c8f2bd6061173e35326fb6a042\",\"dweb:/ipfs/Qmf161h2SEXEQ2oahYcwCkxRC6QZocP2GsSjSJW2K57UzR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"maxAmountUnderlyingInRaw","type":"uint256"},{"internalType":"uint256","name":"maxAmountWrappedInRaw","type":"uint256"},{"internalType":"uint256","name":"exactSharesToIssue","type":"uint256"},{"internalType":"address","name":"sharesOwner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"addLiquidityToBuffer","outputs":[{"internalType":"uint256","name":"amountUnderlyingRaw","type":"uint256"},{"internalType":"uint256","name":"amountWrappedRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"areBuffersPaused","outputs":[{"internalType":"bool","name":"buffersPaused","type":"bool"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"collectAggregateFees","outputs":[{"internalType":"uint256[]","name":"swapFeeAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"yieldFeeAmounts","type":"uint256[]"}]},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"disableQuery"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"disableQueryPermanently"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"disableRecoveryMode"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"enableQuery"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"enableRecoveryMode"},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferAsset","outputs":[{"internalType":"address","name":"underlyingToken","type":"address"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferBalance","outputs":[{"internalType":"uint256","name":"underlyingBalanceRaw","type":"uint256"},{"internalType":"uint256","name":"wrappedBalanceRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getBufferMinimumTotalSupply","outputs":[{"internalType":"uint256","name":"bufferMinimumTotalSupply","type":"uint256"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"address","name":"liquidityOwner","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferOwnerShares","outputs":[{"internalType":"uint256","name":"ownerShares","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getBufferPeriodDuration","outputs":[{"internalType":"uint32","name":"bufferPeriodDuration","type":"uint32"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getBufferPeriodEndTime","outputs":[{"internalType":"uint32","name":"bufferPeriodEndTime","type":"uint32"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferTotalShares","outputs":[{"internalType":"uint256","name":"bufferShares","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getMaximumPoolTokens","outputs":[{"internalType":"uint256","name":"maxTokens","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getMinimumPoolTokens","outputs":[{"internalType":"uint256","name":"minTokens","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumTradeAmount","outputs":[{"internalType":"uint256","name":"minimumTradeAmount","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumWrapAmount","outputs":[{"internalType":"uint256","name":"minimumWrapAmount","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getPauseWindowEndTime","outputs":[{"internalType":"uint32","name":"pauseWindowEndTime","type":"uint32"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getPoolMinimumTotalSupply","outputs":[{"internalType":"uint256","name":"poolMinimumTotalSupply","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getVaultPausedState","outputs":[{"internalType":"bool","name":"vaultPaused","type":"bool"},{"internalType":"uint32","name":"vaultPauseWindowEndTime","type":"uint32"},{"internalType":"uint32","name":"vaultBufferPeriodEndTime","type":"uint32"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"amountUnderlyingRaw","type":"uint256"},{"internalType":"uint256","name":"amountWrappedRaw","type":"uint256"},{"internalType":"uint256","name":"minIssuedShares","type":"uint256"},{"internalType":"address","name":"sharesOwner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"initializeBuffer","outputs":[{"internalType":"uint256","name":"issuedShares","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"isVaultPaused","outputs":[{"internalType":"bool","name":"vaultPaused","type":"bool"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"pausePool"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"pauseVault"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"pauseVaultBuffers"},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"sharesToRemove","type":"uint256"},{"internalType":"uint256","name":"minAmountUnderlyingOutRaw","type":"uint256"},{"internalType":"uint256","name":"minAmountWrappedOutRaw","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"removeLiquidityFromBuffer","outputs":[{"internalType":"uint256","name":"removedUnderlyingBalanceRaw","type":"uint256"},{"internalType":"uint256","name":"removedWrappedBalanceRaw","type":"uint256"}]},{"inputs":[{"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setAuthorizer"},{"inputs":[{"internalType":"contract IProtocolFeeController","name":"newProtocolFeeController","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setProtocolFeeController"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"swapFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"setStaticSwapFeePercentage"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"unpausePool"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"unpauseVault"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"unpauseVaultBuffers"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"newAggregateSwapFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"updateAggregateSwapFeePercentage"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"newAggregateYieldFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"updateAggregateYieldFeePercentage"},{"inputs":[],"stateMutability":"view","type":"function","name":"vault","outputs":[{"internalType":"contract IVault","name":"","type":"address"}]}],"devdoc":{"kind":"dev","methods":{"addLiquidityToBuffer(address,uint256,uint256,uint256,address)":{"details":"The buffer needs to be initialized beforehand.","params":{"exactSharesToIssue":"The value in underlying tokens that `sharesOwner` wants to add to the buffer, in underlying token decimals","maxAmountUnderlyingInRaw":"Maximum amount of underlying tokens to add to the buffer. It is expressed in underlying token native decimals","maxAmountWrappedInRaw":"Maximum amount of wrapped tokens to add to the buffer. It is expressed in wrapped token native decimals","sharesOwner":"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"amountUnderlyingRaw":"Amount of underlying tokens deposited into the buffer","amountWrappedRaw":"Amount of wrapped tokens deposited into the buffer"}},"areBuffersPaused()":{"details":"When buffers are paused, all buffer operations (i.e., calls on the Router with `isBuffer` true) will revert. Pausing buffers is reversible. Note that ERC4626 buffers and the Vault have separate and independent pausing mechanisms. Pausing the Vault does not also pause buffers (though we anticipate they would likely be paused and unpaused together). Call `isVaultPaused` to check the pause state of the Vault.","returns":{"buffersPaused":"True if the Vault buffers are paused"}},"collectAggregateFees(address)":{"details":"Fees are sent to the ProtocolFeeController address.","params":{"pool":"The pool on which all aggregate fees should be collected"},"returns":{"swapFeeAmounts":"An array with the total swap fees collected, sorted in token registration order","yieldFeeAmounts":"An array with the total yield fees collected, sorted in token registration order"}},"disableQuery()":{"details":"The query functions rely on a specific EVM feature to detect static calls. Query operations are exempt from settlement constraints, so it's critical that no state changes can occur. We retain the ability to disable queries in the unlikely event that EVM changes violate its assumptions (perhaps on an L2). This function can be acted upon as an emergency measure in ambiguous contexts where it's not 100% clear whether disabling queries is completely necessary; queries can still be re-enabled after this call."},"disableQueryPermanently()":{"details":"Shall only be used when there is no doubt that queries pose a fundamental threat to the system."},"disableRecoveryMode(address)":{"details":"This is a permissioned function. It re-syncs live balances (which could not be updated during Recovery Mode), forfeiting any yield fees that accrued while enabled. It makes external calls, and could potentially fail if there is an issue with any associated Rate Providers.","params":{"pool":"The address of the pool"}},"enableQuery()":{"details":"Only works if queries are not permanently disabled."},"enableRecoveryMode(address)":{"details":"This is a permissioned function. It enables a safe proportional withdrawal, with no external calls. Since there are no external calls, ensuring that entering Recovery Mode cannot fail, we cannot compute and so must forfeit any yield fees between the last operation and enabling Recovery Mode. For the same reason, live balances cannot be updated while in Recovery Mode, as doing so might cause withdrawals to fail.","params":{"pool":"The address of the pool"}},"getBufferAsset(address)":{"details":"The asset can never change after buffer initialization.","params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"underlyingToken":"Address of the underlying token registered for the wrapper; `address(0)` if the buffer has not been initialized."}},"getBufferBalance(address)":{"details":"All values are in native token decimals of the wrapped or underlying tokens.","params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"underlyingBalanceRaw":"Amount of underlying tokens deposited into the buffer, in native token decimals","wrappedBalanceRaw":"Amount of wrapped tokens deposited into the buffer, in native token decimals"}},"getBufferMinimumTotalSupply()":{"details":"This prevents buffers from being completely drained. When the buffer is initialized, this minimum number of shares is added to the shares resulting from the initial deposit. Buffer total supply accounting is internal to the Vault, as buffers are not tokenized.","returns":{"bufferMinimumTotalSupply":"The minimum total supply a buffer can have after initialization"}},"getBufferOwnerShares(address,address)":{"params":{"liquidityOwner":"Address of the user that owns liquidity in the wrapped token's buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"ownerShares":"Amount of shares allocated to the liquidity owner, in native underlying token decimals"}},"getBufferPeriodDuration()":{"details":"This value is immutable. It represents the period during which, if paused, the Vault will remain paused. This ensures there is time available to address whatever issue caused the Vault to be paused. Balancer timestamps are 32 bits.","returns":{"bufferPeriodDuration":"The length of the buffer period in seconds"}},"getBufferPeriodEndTime()":{"details":"This value is immutable. If already paused, the Vault can be unpaused until this timestamp. Balancer timestamps are 32 bits.","returns":{"bufferPeriodEndTime":"The timestamp after which the Vault remains permanently unpaused"}},"getBufferTotalShares(address)":{"params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"bufferShares":"Amount of supply shares of the buffer, in native underlying token decimals"}},"getMaximumPoolTokens()":{"returns":{"maxTokens":"The maximum token count of a pool"}},"getMinimumPoolTokens()":{"details":"We expect the vast majority of pools to be 2-token.","returns":{"minTokens":"The minimum token count of a pool"}},"getMinimumTradeAmount()":{"details":"This limit is applied to the 18-decimal \"upscaled\" amount in any operation (swap, add/remove liquidity).","returns":{"minimumTradeAmount":"The minimum trade amount as an 18-decimal floating point number"}},"getMinimumWrapAmount()":{"details":"This limit is applied to the wrap operation amount, in native underlying token decimals.","returns":{"minimumWrapAmount":"The minimum wrap amount in native underlying token decimals"}},"getPauseWindowEndTime()":{"details":"This value is immutable, and represents the timestamp after which the Vault can no longer be paused by governance. Balancer timestamps are 32 bits.","returns":{"pauseWindowEndTime":"The timestamp when the Vault's pause window ends"}},"getPoolMinimumTotalSupply()":{"details":"This prevents pools from being completely drained. When the pool is initialized, this minimum amount of BPT is minted to the zero address. This is an 18-decimal floating point number; BPT are always 18 decimals.","returns":{"poolMinimumTotalSupply":"The minimum total supply a pool can have after initialization"}},"getVaultPausedState()":{"details":"Balancer timestamps are 32 bits.","returns":{"vaultBufferPeriodEndTime":"The timestamp of the end of the Vault's buffer period","vaultPauseWindowEndTime":"The timestamp of the end of the Vault's pause window","vaultPaused":"True if the Vault is paused"}},"initializeBuffer(address,uint256,uint256,uint256,address)":{"params":{"amountUnderlyingRaw":"Amount of underlying tokens that will be deposited into the buffer","amountWrappedRaw":"Amount of wrapped tokens that will be deposited into the buffer","minIssuedShares":"Minimum amount of shares to receive from the buffer, expressed in underlying token native decimals","sharesOwner":"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"issuedShares":"the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts. (it is the BPT of an internal ERC4626 buffer). It is expressed in underlying token native decimals."}},"isVaultPaused()":{"details":"If the Vault is paused, all non-Recovery Mode state-changing operations on pools will revert. Note that ERC4626 buffers and the Vault have separate and independent pausing mechanisms. Pausing the Vault does not also pause buffers (though we anticipate they would likely be paused and unpaused together). Call `areBuffersPaused` to check the pause state of the buffers.","returns":{"vaultPaused":"True if the Vault is paused"}},"pausePool(address)":{"details":"This is a permissioned function that will only work during the Pause Window set during pool factory deployment.","params":{"pool":"The pool being paused"}},"pauseVault()":{"details":"This is a permissioned function that will only work during the Pause Window set during deployment. Note that ERC4626 buffer operations have an independent pause mechanism, which is not affected by pausing the Vault. Custom routers could still wrap/unwrap using buffers while the Vault is paused, unless buffers are also paused (with `pauseVaultBuffers`)."},"pauseVaultBuffers()":{"details":"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. Currently it's not possible to pause vault buffers individually. This is a permissioned call, and is reversible (see `unpauseVaultBuffers`). Note that the Vault has a separate and independent pausing mechanism. It is possible to pause the Vault (i.e. pool operations), without affecting buffers, and vice versa."},"removeLiquidityFromBuffer(address,uint256,uint256,uint256)":{"details":"Only proportional exits are supported, and the sender has to be the owner of the shares. This function unlocks the Vault just for this operation; it does not work with a Router as an entrypoint. Pre-conditions: - The buffer needs to be initialized. - sharesOwner is the original msg.sender, it needs to be checked in the Router. That's why   this call is authenticated; only routers approved by the DAO can remove the liquidity of a buffer. - The buffer needs to have some liquidity and have its asset registered in `_bufferAssets` storage.","params":{"minAmountUnderlyingOutRaw":"Minimum amount of underlying tokens to receive from the buffer. It is expressed in underlying token native decimals","minAmountWrappedOutRaw":"Minimum amount of wrapped tokens to receive from the buffer. It is expressed in wrapped token native decimals","sharesToRemove":"Amount of shares to remove from the buffer. Cannot be greater than sharesOwner's total shares. It is expressed in underlying token native decimals","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"removedUnderlyingBalanceRaw":"Amount of underlying tokens returned to the user","removedWrappedBalanceRaw":"Amount of wrapped tokens returned to the user"}},"setAuthorizer(address)":{"details":"This is a permissioned call. Emits an `AuthorizerChanged` event.","params":{"newAuthorizer":"The address of the new authorizer"}},"setProtocolFeeController(address)":{"details":"This is a permissioned call. Emits a `ProtocolFeeControllerChanged` event.","params":{"newProtocolFeeController":"The address of the new Protocol Fee Controller"}},"setStaticSwapFeePercentage(address,uint256)":{"details":"This is a permissioned function, disabled if the pool is paused. The swap fee percentage must be within the bounds specified by the pool's implementation of `ISwapFeePercentageBounds`. Emits the SwapFeePercentageChanged event.","params":{"pool":"The address of the pool for which the static swap fee will be changed","swapFeePercentage":"The new swap fee percentage to apply to the pool"}},"unpausePool(address)":{"details":"This is a permissioned function that will only work on a paused Pool within the Buffer Period set during deployment. Note that the Pool will automatically unpause after the Buffer Period expires.","params":{"pool":"The pool being unpaused"}},"unpauseVault()":{"details":"This is a permissioned function that will only work on a paused Vault within the Buffer Period set during deployment. Note that the Vault will automatically unpause after the Buffer Period expires. As noted above, ERC4626 buffers and Vault operations on pools are independent. Unpausing the Vault does not reverse `pauseVaultBuffers`. If buffers were also paused, they will remain in that state until explicitly unpaused."},"unpauseVaultBuffers()":{"details":"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. As noted above, ERC4626 buffers and Vault operations on pools are independent. Unpausing buffers does not reverse `pauseVault`. If the Vault was also paused, it will remain in that state until explicitly unpaused. This is a permissioned call."},"updateAggregateSwapFeePercentage(address,uint256)":{"details":"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateSwapFeePercentageChanged` event.","params":{"newAggregateSwapFeePercentage":"The new aggregate swap fee percentage","pool":"The pool whose swap fee percentage will be updated"}},"updateAggregateYieldFeePercentage(address,uint256)":{"details":"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateYieldFeePercentageChanged` event.","params":{"newAggregateYieldFeePercentage":"The new aggregate yield fee percentage","pool":"The pool whose yield fee percentage will be updated"}},"vault()":{"details":"The main Vault contains the entrypoint and main liquidity operation implementations.","returns":{"_0":"vault The address of the main Vault"}}},"version":1},"userdoc":{"kind":"user","methods":{"addLiquidityToBuffer(address,uint256,uint256,uint256,address)":{"notice":"Adds liquidity to an internal ERC4626 buffer in the Vault, proportionally."},"areBuffersPaused()":{"notice":"Indicates whether the Vault buffers are paused."},"collectAggregateFees(address)":{"notice":"Collects accumulated aggregate swap and yield fees for the specified pool."},"disableQuery()":{"notice":"Disables query functionality on the Vault. Can only be called by governance."},"disableQueryPermanently()":{"notice":"Disables query functionality permanently on the Vault. Can only be called by governance."},"disableRecoveryMode(address)":{"notice":"Disable recovery mode for a pool."},"enableQuery()":{"notice":"Enables query functionality on the Vault. Can only be called by governance."},"enableRecoveryMode(address)":{"notice":"Enable recovery mode for a pool."},"getBufferAsset(address)":{"notice":"Returns the asset registered for a given wrapped token."},"getBufferBalance(address)":{"notice":"Returns the amount of underlying and wrapped tokens deposited in the internal buffer of the Vault."},"getBufferMinimumTotalSupply()":{"notice":"Get the minimum total supply of an ERC4626 wrapped token buffer in the Vault."},"getBufferOwnerShares(address,address)":{"notice":"Returns the shares (internal buffer BPT) of a liquidity owner: a user that deposited assets in the buffer."},"getBufferPeriodDuration()":{"notice":"Returns the Vault's buffer period duration."},"getBufferPeriodEndTime()":{"notice":"Returns the Vault's buffer period end time."},"getBufferTotalShares(address)":{"notice":"Returns the supply shares (internal buffer BPT) of the ERC4626 buffer."},"getMaximumPoolTokens()":{"notice":"Get the maximum number of tokens in a pool."},"getMinimumPoolTokens()":{"notice":"Get the minimum number of tokens in a pool."},"getMinimumTradeAmount()":{"notice":"Get the minimum trade amount in a pool operation."},"getMinimumWrapAmount()":{"notice":"Get the minimum wrap amount in a buffer operation."},"getPauseWindowEndTime()":{"notice":"Returns the Vault's pause window end time."},"getPoolMinimumTotalSupply()":{"notice":"Get the minimum total supply of pool tokens (BPT) for an initialized pool."},"getVaultPausedState()":{"notice":"Returns the paused status, and end times of the Vault's pause window and buffer period."},"initializeBuffer(address,uint256,uint256,uint256,address)":{"notice":"Initializes buffer for the given wrapped token."},"isVaultPaused()":{"notice":"Indicates whether the Vault is paused."},"pausePool(address)":{"notice":"Pause the Pool: an emergency action which disables all pool functions."},"pauseVault()":{"notice":"Pause the Vault: an emergency action which disables all operational state-changing functions on pools."},"pauseVaultBuffers()":{"notice":"Pauses native vault buffers globally."},"removeLiquidityFromBuffer(address,uint256,uint256,uint256)":{"notice":"Removes liquidity from an internal ERC4626 buffer in the Vault."},"setAuthorizer(address)":{"notice":"Sets a new Authorizer for the Vault."},"setProtocolFeeController(address)":{"notice":"Sets a new Protocol Fee Controller for the Vault."},"setStaticSwapFeePercentage(address,uint256)":{"notice":"Assigns a new static swap fee percentage to the specified pool."},"unpausePool(address)":{"notice":"Reverse a `pause` operation, and restore the Pool to normal functionality."},"unpauseVault()":{"notice":"Reverse a `pause` operation, and restore Vault pool operations to normal functionality."},"unpauseVaultBuffers()":{"notice":"Unpauses native vault buffers globally."},"updateAggregateSwapFeePercentage(address,uint256)":{"notice":"Update an aggregate swap fee percentage."},"updateAggregateYieldFeePercentage(address,uint256)":{"notice":"Update an aggregate yield fee percentage."},"vault()":{"notice":"Returns the main Vault address."}},"version":1}},"settings":{"remappings":["@openzeppelin-4/contracts/=../../node_modules/@openzeppelin/contracts/","@openzeppelin/contracts-upgradeable/=../../node_modules/@openzeppelin/contracts-upgradeable/","@openzeppelin/contracts/=../../node_modules/@openzeppelin/contracts/","balancer-v3-monorepo/=lib/balancer-v3-monorepo/","beefy-zk/=node_modules/beefy-zk/contracts/","forge-std/=lib/forge-std/src/","openzeppelin-contracts-upgradeable/=../../node_modules/@openzeppelin/contracts-upgradeable/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/"],"optimizer":{"enabled":true,"runs":1},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol":"IVaultAdmin"},"evmVersion":"prague","libraries":{},"viaIR":true},"sources":{"../../node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol":{"keccak256":"0x5a173dcd1c1f0074e4df6a9cdab3257e17f2e64f7b8f30ca9e17a8c5ea250e1c","urls":["bzz-raw://7883819ce2b72264a756063ae578661f62b23f4104b08e9565ac075e619f6ce3","dweb:/ipfs/QmcSZdFiEQkWRmZQhnCdfH9ychooV81pBjr7hfaiYiNZT2"],"license":"MIT"},"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"keccak256":"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305","urls":["bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5","dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53"],"license":"MIT"},"../../node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca","urls":["bzz-raw://5a376d3dda2cb70536c0a45c208b29b34ac560c4cb4f513a42079f96ba47d2dd","dweb:/ipfs/QmZQg6gn1sUpM8wHzwNvSnihumUCAhxD119MpXeKp8B9s8"],"license":"MIT"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IAuthentication.sol":{"keccak256":"0xa383f78ec04a4ebadbf64ce0fcef8c14f2487f02330acf2fbab80055c54a5d74","urls":["bzz-raw://077fdb9728fd22008ca58ca9f63cc7ea1b86f9cec778c5ff8943d9322b812f06","dweb:/ipfs/QmVCYYCeuUZK1GqAHzTZBo59cjjh9iQhNYWQvAy2AYAVoN"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x3a9a626d90cdf64042441895ce981bf570d9aa56e7c188b34f8603b1d629aae3","urls":["bzz-raw://0ac7096c0d5cd5e0c20dcc6681d24eb04ad7e14cbb61d0ebf136f96a2b9752c4","dweb:/ipfs/QmWryZQqLxpxaCBwK6uEfSLKWKsGBsDL7xbdGqFMkW4Uxp"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol":{"keccak256":"0x288b9590b9fb743964d46f610c2b0d4eee8457bfe52b890e31be5e11661759e3","urls":["bzz-raw://11373e74f2bb6112ae47b709e0161c09b3a2e1a7659bd15fa4ab4bcf8eadcab0","dweb:/ipfs/QmfELyCgCckJz6hPwCw9thNA5kvaoUcCw7gcoxRgWrjMg1"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol":{"keccak256":"0x51fabcdeaefc15a895a04c457968a7fc0ce4f4647d42a91d07a863170d812c28","urls":["bzz-raw://85822ed25a050521ec4b1af2e21d48e2b85cf48828cb9be5d7e5eb104d4ade6a","dweb:/ipfs/QmU4QSNMfQCEacdgQizCxgNUzfnKxdmyqAndNJgLsCQ32t"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IProtocolFeeController.sol":{"keccak256":"0xa549105cdf64e06ab49473ab810b4ec2342e7e1593707a297f7965044d75fdb1","urls":["bzz-raw://f641d0f440b2085580aa8b79cb3241bc0c3ea0af275fad953d727ec8f7482795","dweb:/ipfs/QmPULYHXMhCGCztE5ccKzRhb99K3LJSAicbxpWm36gcFVg"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVault.sol":{"keccak256":"0xf02dcb0b4fe9b71eb46fc66e327e166091d4e479fc3987c766859c94d505fe03","urls":["bzz-raw://de42ab0fa6f22010ac305d785e787a60fbb94c2d0ba17042a6e60bce33c5ed9f","dweb:/ipfs/QmVonnCCZVGzA3EERuQ4PbtpTTKrtgoXxYmtJ4CqaSmc4e"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol":{"keccak256":"0x9a651c10b5b352386341d65a37b63c95fbd0c4d401d4539730f3dfb4825acc18","urls":["bzz-raw://26e398b4fc37c80a86327b9cbe14335e5378fa69b3fb222c2dc8cf33707c30fd","dweb:/ipfs/QmY2E1b8DADLp3MStbVK93GACRJgJZxHYJpDrow1xzVhWB"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultErrors.sol":{"keccak256":"0xb2c6deaa8701201af5d31ac270fbc30ebe6b66a1f9b6b12d1d17d807f7decb66","urls":["bzz-raw://28d6751bc7e7c7221745742cfe906387e0d806ea0a0041b9377fb5a537146063","dweb:/ipfs/QmcphjQ6ramZM6Qxv84jaJbtZ7d5FNFJ8xHWCHZwk7CdZ3"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultEvents.sol":{"keccak256":"0x0ff416b358949bb5d9553118f7cbfd42aa9aa33fa6bbe4bf470159df07cf6989","urls":["bzz-raw://f033bb516eb8d85554aea408a0a750bf6ccd5655035abd307cc8388a533f1c40","dweb:/ipfs/QmPCjG5jrXU4FrJWsputirF7JXZsNxhopetnHZTfRAFvMn"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultExtension.sol":{"keccak256":"0xa547348926764942de6030bf7d303684ff675a4a08fab3320f98154450ca5bb8","urls":["bzz-raw://6c440d5d23034e35803f135d9336f256ece717370adb93d1f2fb992fa5ffd869","dweb:/ipfs/QmbCaxRG3X9kUEbdrhRbm7JZZoK2nYp8FUXqh7Bn4wnFra"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":{"keccak256":"0x7df60e55516bf9cfa5156a03afc22e222fb87edf1bb9af48586ff0ff1be71e92","urls":["bzz-raw://baf5a2e16cdb139182df24e2d103f80c72b730be20a04b2486e751af16652ac9","dweb:/ipfs/Qmd6kdQmUFxPRJT1YrRJVVsUYAmpohBRvCM2qdXzVGcv5d"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0x670a4c7cdc970ed8cc82432894318558d67a530591617177603e0fea631addbc","urls":["bzz-raw://b240af11378ac8ce54000b7defbd63c3a78d34c8f2bd6061173e35326fb6a042","dweb:/ipfs/Qmf161h2SEXEQ2oahYcwCkxRC6QZocP2GsSjSJW2K57UzR"],"license":"GPL-3.0-or-later"}},"version":1},"id":83}